'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDefaultCertificate = exports.isSupportedOnCurrentPlatform = undefined;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _bluebird = require('bluebird');

let createDefaultCertificate = exports.createDefaultCertificate = (() => {
  var _ref2 = (0, _bluebird.coroutine)(function* (publisherName, { certFilePath, certFileName, install, program }) {
    const makeCertOptions = {
      publisherName,
      certFilePath: certFilePath || process.cwd(),
      certFileName: certFileName || 'default',
      install: typeof install === 'boolean' ? install : false,
      program: program || { windowsKit: _path2.default.dirname(findSdkTool('makecert.exe')) }
    };

    if (!(0, _sign.isValidPublisherName)(publisherName)) {
      throw new Error(`Received invalid publisher name: '${publisherName}' did not conform to X.500 distinguished name syntax for MakeCert.`);
    }

    return yield (0, _sign.makeCert)(makeCertOptions);
  });

  return function createDefaultCertificate(_x, _x2) {
    return _ref2.apply(this, arguments);
  };
})();

exports.getDistinguishedNameFromAuthor = getDistinguishedNameFromAuthor;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _parseAuthor = require('parse-author');

var _parseAuthor2 = _interopRequireDefault(_parseAuthor);

var _electronWindowsStore = require('electron-windows-store');

var _electronWindowsStore2 = _interopRequireDefault(_electronWindowsStore);

var _sign = require('electron-windows-store/lib/sign');

var _resolveCommand = require('cross-spawn/lib/util/resolveCommand');

var _resolveCommand2 = _interopRequireDefault(_resolveCommand);

var _ensureOutput = require('../../util/ensure-output');

var _configFn = require('../../util/config-fn');

var _configFn2 = _interopRequireDefault(_configFn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// electron-windows-store doesn't set its 'os' field even though it only runs on
// win32
const isSupportedOnCurrentPlatform = exports.isSupportedOnCurrentPlatform = (() => {
  var _ref = (0, _bluebird.coroutine)(function* () {
    return process.platform === 'win32';
  });

  return function isSupportedOnCurrentPlatform() {
    return _ref.apply(this, arguments);
  };
})();

// NB: This is not a typo, we require AppXs to be built on 64-bit
// but if we're running in a 32-bit node.js process, we're going to
// be Wow64 redirected
const windowsSdkPath = process.arch === 'x64' ? 'C:\\Program Files (x86)\\Windows Kits\\10\\bin\\x64' : 'C:\\Program Files\\Windows Kits\\10\\bin\\x64';

function findSdkTool(exe) {
  let sdkTool = _path2.default.join(windowsSdkPath, exe);
  if (!_fs2.default.existsSync(sdkTool)) {
    sdkTool = (0, _resolveCommand2.default)(exe, true);
  }

  if (!_fs2.default.existsSync(sdkTool)) {
    throw new Error(`Can't find ${exe} in PATH. You probably need to install the Windows SDK.`);
  }

  return sdkTool;
}

function getDistinguishedNameFromAuthor(author) {
  let publisher = author || '';

  if (typeof publisher === 'string') {
    publisher = (0, _parseAuthor2.default)(publisher);
  }

  if (typeof publisher.name === 'string') {
    publisher = publisher.name;
  }

  if (typeof publisher !== 'string') {
    publisher = '';
  }

  return `CN=${publisher}`;
}

exports.default = (() => {
  var _ref3 = (0, _bluebird.coroutine)(function* ({ dir, appName, targetArch, forgeConfig, packageJSON }) {
    const outPath = _path2.default.resolve(dir, `../make/appx/${targetArch}`);
    yield (0, _ensureOutput.ensureDirectory)(outPath);

    const userConfig = (0, _configFn2.default)(forgeConfig.windowsStoreConfig, targetArch);

    const opts = (0, _assign2.default)({
      publisher: getDistinguishedNameFromAuthor(packageJSON.author),
      flatten: false,
      deploy: false,
      packageVersion: `${packageJSON.version}.0`,
      packageName: appName.replace(/-/g, ''),
      packageDisplayName: appName,
      packageDescription: packageJSON.description || appName,
      packageExecutable: `app\\${appName}.exe`,
      windowsKit: userConfig.windowsKit || _path2.default.dirname(findSdkTool('makeappx.exe'))
    }, userConfig, {
      inputDirectory: dir,
      outputDirectory: outPath
    });

    if (!opts.publisher) {
      throw 'Please set config.forge.windowsStoreConfig.publisher or author.name in package.json for the appx target';
    }

    if (!opts.devCert) {
      opts.devCert = yield createDefaultCertificate(opts.publisher, { certFilePath: outPath, program: opts });
    }

    if (opts.packageVersion.match(/-/)) {
      if (opts.makeVersionWinStoreCompatible) {
        const noBeta = opts.packageVersion.replace(/-.*/, '');
        opts.packageVersion = `${noBeta}.0`;
      } else {
        const err = "Windows Store version numbers don't support semver beta tags. To" + 'automatically fix this, set makeVersionWinStoreCompatible to true or ' + 'explicitly set packageVersion to a version of the format X.Y.Z.A';

        throw new Error(err);
      }
    }

    delete opts.makeVersionWinStoreCompatible;

    yield (0, _electronWindowsStore2.default)(opts);

    return [_path2.default.resolve(outPath, `${opts.packageName}.appx`)];
  });

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1ha2Vycy93aW4zMi9hcHB4LmpzIl0sIm5hbWVzIjpbInB1Ymxpc2hlck5hbWUiLCJjZXJ0RmlsZVBhdGgiLCJjZXJ0RmlsZU5hbWUiLCJpbnN0YWxsIiwicHJvZ3JhbSIsIm1ha2VDZXJ0T3B0aW9ucyIsInByb2Nlc3MiLCJjd2QiLCJ3aW5kb3dzS2l0IiwiZGlybmFtZSIsImZpbmRTZGtUb29sIiwiRXJyb3IiLCJjcmVhdGVEZWZhdWx0Q2VydGlmaWNhdGUiLCJnZXREaXN0aW5ndWlzaGVkTmFtZUZyb21BdXRob3IiLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwicGxhdGZvcm0iLCJ3aW5kb3dzU2RrUGF0aCIsImFyY2giLCJleGUiLCJzZGtUb29sIiwiam9pbiIsImV4aXN0c1N5bmMiLCJhdXRob3IiLCJwdWJsaXNoZXIiLCJuYW1lIiwiZGlyIiwiYXBwTmFtZSIsInRhcmdldEFyY2giLCJmb3JnZUNvbmZpZyIsInBhY2thZ2VKU09OIiwib3V0UGF0aCIsInJlc29sdmUiLCJ1c2VyQ29uZmlnIiwid2luZG93c1N0b3JlQ29uZmlnIiwib3B0cyIsImZsYXR0ZW4iLCJkZXBsb3kiLCJwYWNrYWdlVmVyc2lvbiIsInZlcnNpb24iLCJwYWNrYWdlTmFtZSIsInJlcGxhY2UiLCJwYWNrYWdlRGlzcGxheU5hbWUiLCJwYWNrYWdlRGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbiIsInBhY2thZ2VFeGVjdXRhYmxlIiwiaW5wdXREaXJlY3RvcnkiLCJvdXRwdXREaXJlY3RvcnkiLCJkZXZDZXJ0IiwibWF0Y2giLCJtYWtlVmVyc2lvbldpblN0b3JlQ29tcGF0aWJsZSIsIm5vQmV0YSIsImVyciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7dUNBa0NPLFdBQXdDQSxhQUF4QyxFQUF1RCxFQUFFQyxZQUFGLEVBQWdCQyxZQUFoQixFQUE4QkMsT0FBOUIsRUFBdUNDLE9BQXZDLEVBQXZELEVBQXlHO0FBQzlHLFVBQU1DLGtCQUFrQjtBQUN0QkwsbUJB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eEIsVUFBWCxJQUF5QixlQUFLQyxPQUFMLENBQWFDLFlBQVksY0FBWixDQUFiO0FBVFosS0FBZCxFQVVWc0IsVUFWVSxFQVVFO0FBQ2JhLHNCQUFnQnBCLEdBREg7QUFFYnFCLHVCQUFpQmhCO0FBRkosS0FWRixDQUFiOztBQWVBLFFBQUksQ0FBQ0ksS0FBS1gsU0FBVixFQUFxQjtBQUNuQixZQUFNLHlHQUFOO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDVyxLQUFLYSxPQUFWLEVBQW1CO0FBQ2pCYixXQUFLYSxPQUFMLEdBQWUsTUFBTW5DLHlCQUF5QnNCLEtBQUtYLFNBQTlCLEVBQXlDLEVBQUV0QixjQUFjNkIsT0FBaEIsRUFBeUIxQixTQUFTOEIsSUFBbEMsRUFBekMsQ0FBckI7QUFDRDs7QUFFRCxRQUFJQSxLQUFLRyxjQUFMLENBQW9CVyxLQUFwQixDQUEwQixHQUExQixDQUFKLEVBQW9DO0FBQ2xDLFVBQUlkLEtBQUtlLDZCQUFULEVBQXdDO0FBQ3RDLGNBQU1DLFNBQVNoQixLQUFLRyxjQUFMLENBQW9CRyxPQUFwQixDQUE0QixLQUE1QixFQUFtQyxFQUFuQyxDQUFmO0FBQ0FOLGFBQUtHLGNBQUwsR0FBdUIsR0FBRWEsTUFBTyxJQUFoQztBQUNELE9BSEQsTUFHTztBQUNMLGNBQU1DLE1BQU0scUVBQ1YsdUVBRFUsR0FFVixrRUFGRjs7QUFJQSxjQUFNLElBQUl4QyxLQUFKLENBQVV3QyxHQUFWLENBQU47QUFDRDtBQUNGOztBQUVELFdBQU9qQixLQUFLZSw2QkFBWjs7QUFFQSxVQUFNLG9DQUFhZixJQUFiLENBQU47O0FBRUEsV0FBTyxDQUFDLGVBQUtILE9BQUwsQ0FBYUQsT0FBYixFQUF1QixHQUFFSSxLQUFLSyxXQUFZLE9BQTFDLENBQUQsQ0FBUDtBQUNELEciLCJmaWxlIjoibWFrZXJzL3dpbjMyL2FwcHguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgcGFyc2VBdXRob3IgZnJvbSAncGFyc2UtYXV0aG9yJztcbmltcG9ydCB3aW5kb3dzU3RvcmUgZnJvbSAnZWxlY3Ryb24td2luZG93cy1zdG9yZSc7XG5pbXBvcnQgeyBpc1ZhbGlkUHVibGlzaGVyTmFtZSwgbWFrZUNlcnQgfSBmcm9tICdlbGVjdHJvbi13aW5kb3dzLXN0b3JlL2xpYi9zaWduJztcblxuaW1wb3J0IHJlc29sdmVDb21tYW5kIGZyb20gJ2Nyb3NzLXNwYXduL2xpYi91dGlsL3Jlc29sdmVDb21tYW5kJztcbmltcG9ydCB7IGVuc3VyZURpcmVjdG9yeSB9IGZyb20gJy4uLy4uL3V0aWwvZW5zdXJlLW91dHB1dCc7XG5pbXBvcnQgY29uZmlnRm4gZnJvbSAnLi4vLi4vdXRpbC9jb25maWctZm4nO1xuXG4vLyBlbGVjdHJvbi13aW5kb3dzLXN0b3JlIGRvZXNuJ3Qgc2V0IGl0cyAnb3MnIGZpZWxkIGV2ZW4gdGhvdWdoIGl0IG9ubHkgcnVucyBvblxuLy8gd2luMzJcbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtID0gYXN5bmMgKCkgPT4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcblxuLy8gTkI6IFRoaXMgaXMgbm90IGEgdHlwbywgd2UgcmVxdWlyZSBBcHBYcyB0byBiZSBidWlsdCBvbiA2NC1iaXRcbi8vIGJ1dCBpZiB3ZSdyZSBydW5uaW5nIGluIGEgMzItYml0IG5vZGUuanMgcHJvY2Vzcywgd2UncmUgZ29pbmcgdG9cbi8vIGJlIFdvdzY0IHJlZGlyZWN0ZWRcbmNvbnN0IHdpbmRvd3NTZGtQYXRoID0gcHJvY2Vzcy5hcmNoID09PSAneDY0JyA/XG4gICdDOlxcXFxQcm9ncmFtIEZpbGVzICh4ODYpXFxcXFdpbmRvd3MgS2l0c1xcXFwxMFxcXFxiaW5cXFxceDY0JyA6XG4gICdDOlxcXFxQcm9ncmFtIEZpbGVzXFxcXFdpbmRvd3MgS2l0c1xcXFwxMFxcXFxiaW5cXFxceDY0JztcblxuZnVuY3Rpb24gZmluZFNka1Rvb2woZXhlKSB7XG4gIGxldCBzZGtUb29sID0gcGF0aC5qb2luKHdpbmRvd3NTZGtQYXRoLCBleGUpO1xuICBpZiAoIWZzLmV4aXN0c1N5bmMoc2RrVG9vbCkpIHtcbiAgICBzZGtUb29sID0gcmVzb2x2ZUNvbW1hbmQoZXhlLCB0cnVlKTtcbiAgfVxuXG4gIGlmICghZnMuZXhpc3RzU3luYyhzZGtUb29sKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCAke2V4ZX0gaW4gUEFUSC4gWW91IHByb2JhYmx5IG5lZWQgdG8gaW5zdGFsbCB0aGUgV2luZG93cyBTREsuYCk7XG4gIH1cblxuICByZXR1cm4gc2RrVG9vbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRDZXJ0aWZpY2F0ZShwdWJsaXNoZXJOYW1lLCB7IGNlcnRGaWxlUGF0aCwgY2VydEZpbGVOYW1lLCBpbnN0YWxsLCBwcm9ncmFtIH0pIHtcbiAgY29uc3QgbWFrZUNlcnRPcHRpb25zID0ge1xuICAgIHB1Ymxpc2hlck5hbWUsXG4gICAgY2VydEZpbGVQYXRoOiBjZXJ0RmlsZVBhdGggfHwgcHJvY2Vzcy5jd2QoKSxcbiAgICBjZXJ0RmlsZU5hbWU6IGNlcnRGaWxlTmFtZSB8fCAnZGVmYXVsdCcsXG4gICAgaW5zdGFsbDogdHlwZW9mIGluc3RhbGwgPT09ICdib29sZWFuJyA/IGluc3RhbGwgOiBmYWxzZSxcbiAgICBwcm9ncmFtOiBwcm9ncmFtIHx8IHsgd2luZG93c0tpdDogcGF0aC5kaXJuYW1lKGZpbmRTZGtUb29sKCdtYWtlY2VydC5leGUnKSkgfSxcbiAgfTtcblxuICBpZiAoIWlzVmFsaWRQdWJsaXNoZXJOYW1lKHB1Ymxpc2hlck5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBpbnZhbGlkIHB1Ymxpc2hlciBuYW1lOiAnJHtwdWJsaXNoZXJOYW1lfScgZGlkIG5vdCBjb25mb3JtIHRvIFguNTAwIGRpc3Rpbmd1aXNoZWQgbmFtZSBzeW50YXggZm9yIE1ha2VDZXJ0LmApO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IG1ha2VDZXJ0KG1ha2VDZXJ0T3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0aW5ndWlzaGVkTmFtZUZyb21BdXRob3IoYXV0aG9yKSB7XG4gIGxldCBwdWJsaXNoZXIgPSBhdXRob3IgfHwgJyc7XG5cbiAgaWYgKHR5cGVvZiBwdWJsaXNoZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgcHVibGlzaGVyID0gcGFyc2VBdXRob3IocHVibGlzaGVyKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHVibGlzaGVyLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcHVibGlzaGVyID0gcHVibGlzaGVyLm5hbWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHB1Ymxpc2hlciAhPT0gJ3N0cmluZycpIHtcbiAgICBwdWJsaXNoZXIgPSAnJztcbiAgfVxuXG4gIHJldHVybiBgQ049JHtwdWJsaXNoZXJ9YDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHsgZGlyLCBhcHBOYW1lLCB0YXJnZXRBcmNoLCBmb3JnZUNvbmZpZywgcGFja2FnZUpTT04gfSkgPT4ge1xuICBjb25zdCBvdXRQYXRoID0gcGF0aC5yZXNvbHZlKGRpciwgYC4uL21ha2UvYXBweC8ke3RhcmdldEFyY2h9YCk7XG4gIGF3YWl0IGVuc3VyZURpcmVjdG9yeShvdXRQYXRoKTtcblxuICBjb25zdCB1c2VyQ29uZmlnID0gY29uZmlnRm4oZm9yZ2VDb25maWcud2luZG93c1N0b3JlQ29uZmlnLCB0YXJnZXRBcmNoKTtcblxuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcHVibGlzaGVyOiBnZXREaXN0aW5ndWlzaGVkTmFtZUZyb21BdXRob3IocGFja2FnZUpTT04uYXV0aG9yKSxcbiAgICBmbGF0dGVuOiBmYWxzZSxcbiAgICBkZXBsb3k6IGZhbHNlLFxuICAgIHBhY2thZ2VWZXJzaW9uOiBgJHtwYWNrYWdlSlNPTi52ZXJzaW9ufS4wYCxcbiAgICBwYWNrYWdlTmFtZTogYXBwTmFtZS5yZXBsYWNlKC8tL2csICcnKSxcbiAgICBwYWNrYWdlRGlzcGxheU5hbWU6IGFwcE5hbWUsXG4gICAgcGFja2FnZURlc2NyaXB0aW9uOiBwYWNrYWdlSlNPTi5kZXNjcmlwdGlvbiB8fCBhcHBOYW1lLFxuICAgIHBhY2thZ2VFeGVjdXRhYmxlOiBgYXBwXFxcXCR7YXBwTmFtZX0uZXhlYCxcbiAgICB3aW5kb3dzS2l0OiB1c2VyQ29uZmlnLndpbmRvd3NLaXQgfHwgcGF0aC5kaXJuYW1lKGZpbmRTZGtUb29sKCdtYWtlYXBweC5leGUnKSksXG4gIH0sIHVzZXJDb25maWcsIHtcbiAgICBpbnB1dERpcmVjdG9yeTogZGlyLFxuICAgIG91dHB1dERpcmVjdG9yeTogb3V0UGF0aCxcbiAgfSk7XG5cbiAgaWYgKCFvcHRzLnB1Ymxpc2hlcikge1xuICAgIHRocm93ICdQbGVhc2Ugc2V0IGNvbmZpZy5mb3JnZS53aW5kb3dzU3RvcmVDb25maWcucHVibGlzaGVyIG9yIGF1dGhvci5uYW1lIGluIHBhY2thZ2UuanNvbiBmb3IgdGhlIGFwcHggdGFyZ2V0JztcbiAgfVxuXG4gIGlmICghb3B0cy5kZXZDZXJ0KSB7XG4gICAgb3B0cy5kZXZDZXJ0ID0gYXdhaXQgY3JlYXRlRGVmYXVsdENlcnRpZmljYXRlKG9wdHMucHVibGlzaGVyLCB7IGNlcnRGaWxlUGF0aDogb3V0UGF0aCwgcHJvZ3JhbTogb3B0cyB9KTtcbiAgfVxuXG4gIGlmIChvcHRzLnBhY2thZ2VWZXJzaW9uLm1hdGNoKC8tLykpIHtcbiAgICBpZiAob3B0cy5tYWtlVmVyc2lvbldpblN0b3JlQ29tcGF0aWJsZSkge1xuICAgICAgY29uc3Qgbm9CZXRhID0gb3B0cy5wYWNrYWdlVmVyc2lvbi5yZXBsYWNlKC8tLiovLCAnJyk7XG4gICAgICBvcHRzLnBhY2thZ2VWZXJzaW9uID0gYCR7bm9CZXRhfS4wYDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyID0gXCJXaW5kb3dzIFN0b3JlIHZlcnNpb24gbnVtYmVycyBkb24ndCBzdXBwb3J0IHNlbXZlciBiZXRhIHRhZ3MuIFRvXCIgK1xuICAgICAgICAnYXV0b21hdGljYWxseSBmaXggdGhpcywgc2V0IG1ha2VWZXJzaW9uV2luU3RvcmVDb21wYXRpYmxlIHRvIHRydWUgb3IgJyArXG4gICAgICAgICdleHBsaWNpdGx5IHNldCBwYWNrYWdlVmVyc2lvbiB0byBhIHZlcnNpb24gb2YgdGhlIGZvcm1hdCBYLlkuWi5BJztcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlIG9wdHMubWFrZVZlcnNpb25XaW5TdG9yZUNvbXBhdGlibGU7XG5cbiAgYXdhaXQgd2luZG93c1N0b3JlKG9wdHMpO1xuXG4gIHJldHVybiBbcGF0aC5yZXNvbHZlKG91dFBhdGgsIGAke29wdHMucGFja2FnZU5hbWV9LmFwcHhgKV07XG59O1xuIl19
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unmountImage = exports.mountImage = exports.getMountedImages = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _bluebird = require('bluebird');

var _crossSpawnPromise = require('cross-spawn-promise');

var _crossSpawnPromise2 = _interopRequireDefault(_crossSpawnPromise);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const d = (0, _debug2.default)('electron-forge:hdiutil');

const getMountedImages = exports.getMountedImages = (() => {
  var _ref = (0, _bluebird.coroutine)(function* () {
    const output = yield (0, _crossSpawnPromise2.default)('hdiutil', ['info']);
    const mounts = output.split(/====\n/g);
    mounts.shift();

    const mountObjects = [];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(mounts), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const mount = _step.value;

        try {
          const mountPath = /\/Volumes\/(.+)\n/g.exec(mount)[1];
          const imagePath = /image-path +: +(.+)\n/g.exec(mount)[1];
          mountObjects.push({ mountPath, imagePath });
        } catch (err) {
          // Ignore
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    d('identified active mounts', mountObjects);
    return mountObjects;
  });

  return function getMountedImages() {
    return _ref.apply(this, arguments);
  };
})();

const mountImage = exports.mountImage = (() => {
  var _ref2 = (0, _bluebird.coroutine)(function* (filePath) {
    d('mounting image:', filePath);
    const output = yield (0, _crossSpawnPromise2.default)('hdiutil', ['attach', '-noautoopen', '-nobrowse', '-noverify', filePath]).toString();
    const mountPath = /\/Volumes\/(.+)\n/g.exec(output)[1];
    d('mounted at:', mountPath);

    return {
      mountPath,
      imagePath: filePath
    };
  });

  return function mountImage(_x) {
    return _ref2.apply(this, arguments);
  };
})();

const unmountImage = exports.unmountImage = (() => {
  var _ref3 = (0, _bluebird.coroutine)(function* (mount) {
    d('unmounting current mount:', mount);
    yield (0, _crossSpawnPromise2.default)('hdiutil', ['unmount', '-force', `/Volumes/${mount.mountPath}`]);
  });

  return function unmountImage(_x2) {
    return _ref3.apply(this, arguments);
  };
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInV0aWwvaGRpdXRpbC5qcyJdLCJuYW1lcyI6WyJkIiwiZ2V0TW91bnRlZEltYWdlcyIsIm91dHB1dCIsIm1vdW50cyIsInNwbGl0Iiwic2hpZnQiLCJtb3VudE9iamVjdHMiLCJtb3VudCIsIm1vdW50UGF0aCIsImV4ZWMiLCJpbWFnZVBhdGgiLCJwdXNoIiwiZXJyIiwibW91bnRJbWFnZSIsImZpbGVQYXRoIiwidG9TdHJpbmciLCJ1bm1vdW50SW1hZ2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxJQUFJLHFCQUFNLHdCQUFOLENBQVY7O0FBRU8sTUFBTUM7QUFBQSxzQ0FBbUIsYUFBWTtBQUMxQyxVQUFNQyxTQUFTLE1BQU0saUNBQWEsU0FBYixFQUF3QixDQUFDLE1BQUQsQ0FBeEIsQ0FBckI7QUFDQSxVQUFNQyxTQUFTRCxPQUFPRSxLQUFQLENBQWEsU0FBYixDQUFmO0FBQ0FELFdBQU9FLEtBQVA7O0FBRUEsVUFBTUMsZUFBZSxFQUFyQjs7QUFMMEM7QUFBQTtBQUFBOztBQUFBO0FBTzFDLHNEQUFvQkgsTUFBcEIsNEdBQTRCO0FBQUEsY0FBakJJLEtBQWlCOztBQUMxQixZQUFJO0FBQ0YsZ0JBQU1DLFlBQVkscUJBQXFCQyxJQUFyQixDQUEwQkYsS0FBMUIsRUFBaUMsQ0FBakMsQ0FBbEI7QUFDQSxnQkFBTUcsWUFBWSx5QkFBeUJELElBQXpCLENBQThCRixLQUE5QixFQUFxQyxDQUFyQyxDQUFsQjtBQUNBRCx1QkFBYUssSUFBYixDQUFrQixFQUFFSCxTQUFGLEVBQWFFLFNBQWIsRUFBbEI7QUFDRCxTQUpELENBSUUsT0FBT0UsR0FBUCxFQUFZO0FBQ1o7QUFDRDtBQUNGO0FBZnlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBaUIxQ1osTUFBRSwwQkFBRixFQUE4Qk0sWUFBOUI7QUFDQSxXQUFPQSxZQUFQO0FBQ0QsR0FuQlk7O0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBTjs7QUFxQkEsTUFBTU87QUFBQSx1Q0FBYSxXQUFPQyxRQUFQLEVBQW9CO0FBQzVDZCxNQUFFLGlCQUFGLEVBQXFCYyxRQUFyQjtBQUNBLFVBQU1aLFNBQVMsTUFBTSxpQ0FBYSxTQUFiLEVBQXdCLENBQUMsUUFBRCxFQUFXLGFBQVgsRUFBMEIsV0FBMUIsRUFBdUMsV0FBdkMsRUFBb0RZLFFBQXBELENBQXhCLEVBQXVGQyxRQUF2RixFQUFyQjtBQUNBLFVBQU1QLFlBQVkscUJBQXFCQyxJQUFyQixDQUEwQlAsTUFBMUIsRUFBa0MsQ0FBbEMsQ0FBbEI7QUFDQUYsTUFBRSxhQUFGLEVBQWlCUSxTQUFqQjs7QUFFQSxXQUFPO0FBQ0xBLGVBREs7QUFFTEUsaUJBQVdJO0FBRk4sS0FBUDtBQUlELEdBVlk7O0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBTjs7QUFZQSxNQUFNRTtBQUFBLHVDQUFlLFdBQU9ULEtBQVAsRUFBaUI7QUFDM0NQLE1BQUUsMkJBQUYsRUFBK0JPLEtBQS9CO0FBQ0EsVUFBTSxpQ0FBYSxTQUFiLEVBQXdCLENBQUMsU0FBRCxFQUFZLFFBQVosRUFBdUIsWUFBV0EsTUFBTUMsU0FBVSxFQUFsRCxDQUF4QixDQUFOO0FBQ0QsR0FIWTs7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFOIiwiZmlsZSI6InV0aWwvaGRpdXRpbC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzcGF3blByb21pc2UgZnJvbSAnY3Jvc3Mtc3Bhd24tcHJvbWlzZSc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOmhkaXV0aWwnKTtcblxuZXhwb3J0IGNvbnN0IGdldE1vdW50ZWRJbWFnZXMgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IG91dHB1dCA9IGF3YWl0IHNwYXduUHJvbWlzZSgnaGRpdXRpbCcsIFsnaW5mbyddKTtcbiAgY29uc3QgbW91bnRzID0gb3V0cHV0LnNwbGl0KC89PT09XFxuL2cpO1xuICBtb3VudHMuc2hpZnQoKTtcblxuICBjb25zdCBtb3VudE9iamVjdHMgPSBbXTtcblxuICBmb3IgKGNvbnN0IG1vdW50IG9mIG1vdW50cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtb3VudFBhdGggPSAvXFwvVm9sdW1lc1xcLyguKylcXG4vZy5leGVjKG1vdW50KVsxXTtcbiAgICAgIGNvbnN0IGltYWdlUGF0aCA9IC9pbWFnZS1wYXRoICs6ICsoLispXFxuL2cuZXhlYyhtb3VudClbMV07XG4gICAgICBtb3VudE9iamVjdHMucHVzaCh7IG1vdW50UGF0aCwgaW1hZ2VQYXRoIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWdub3JlXG4gICAgfVxuICB9XG5cbiAgZCgnaWRlbnRpZmllZCBhY3RpdmUgbW91bnRzJywgbW91bnRPYmplY3RzKTtcbiAgcmV0dXJuIG1vdW50T2JqZWN0cztcbn07XG5cbmV4cG9ydCBjb25zdCBtb3VudEltYWdlID0gYXN5bmMgKGZpbGVQYXRoKSA9PiB7XG4gIGQoJ21vdW50aW5nIGltYWdlOicsIGZpbGVQYXRoKTtcbiAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgc3Bhd25Qcm9taXNlKCdoZGl1dGlsJywgWydhdHRhY2gnLCAnLW5vYXV0b29wZW4nLCAnLW5vYnJvd3NlJywgJy1ub3ZlcmlmeScsIGZpbGVQYXRoXSkudG9TdHJpbmcoKTtcbiAgY29uc3QgbW91bnRQYXRoID0gL1xcL1ZvbHVtZXNcXC8oLispXFxuL2cuZXhlYyhvdXRwdXQpWzFdO1xuICBkKCdtb3VudGVkIGF0OicsIG1vdW50UGF0aCk7XG5cbiAgcmV0dXJuIHtcbiAgICBtb3VudFBhdGgsXG4gICAgaW1hZ2VQYXRoOiBmaWxlUGF0aCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1bm1vdW50SW1hZ2UgPSBhc3luYyAobW91bnQpID0+IHtcbiAgZCgndW5tb3VudGluZyBjdXJyZW50IG1vdW50OicsIG1vdW50KTtcbiAgYXdhaXQgc3Bhd25Qcm9taXNlKCdoZGl1dGlsJywgWyd1bm1vdW50JywgJy1mb3JjZScsIGAvVm9sdW1lcy8ke21vdW50Lm1vdW50UGF0aH1gXSk7XG59O1xuIl19